//
//  13909.swift
//  baekjun
//
//  Created by Mi Gyeong Park on 8/19/24.
//

import Foundation

func onetnzn() {
    /**
     Swift 코드에서 런타임 에러가 발생하는 이유는 아마도 반복문에서 i가 1...n 범위를 가지고 있을 때, n이 0일 경우 배열의 인덱스를 초과하는 상황이 발생할 수 있기 때문입니다. 이 문제를 해결하려면 n이 0일 때를 고려하여 특별히 처리해주어야 합니다.

     예를 들어, n = 0인 경우에는 반복문을 실행하지 않아야 합니다.
     */
    if let input = readLine(), let n = Int(input), n > 0 {
        
        var windows = Array(repeating: 0, count: n)
        
        for i in 1...n {
            for (index, window) in windows.enumerated() {
                if (index + 1) % i == 0 {
                    windows[index] = window == 1 ? 0 : 1
                }
            }
                
        }
        
        print(windows.filter{ $0 == 1 }.count)
    } else {
        print(0)
    }
    
    /**
     n의 범위가 1 ≤ n ≤ 2,100,000,000인 경우, 이 문제는 매우 큰 입력 값을 다루어야 합니다. 이 때문에 배열을 사용하는 접근법은 메모리와 시간 복잡도 측면에서 비효율적입니다. 특히, n이 2,100,000,000에 가까운 경우, 메모리에 이 배열을 모두 할당하는 것은 불가능합니다.

     문제 분석 및 최적화

     이 문제는 사실 “창문을 여닫는 문제”로, 특정 수의 배수 인덱스를 가진 창문을 여닫는 상황을 시뮬레이션하고 있습니다. 이 문제를 최적화하기 위해서 중요한 통찰은 다음과 같습니다:

         •    창문이 최종적으로 열려 있는지 닫혀 있는지는 그 인덱스의 약수 개수에 따라 결정됩니다.
         •    약수의 개수가 홀수인 경우 창문이 열리고, 짝수인 경우 닫힙니다.
         •    약수의 개수가 홀수인 경우는 해당 수가 완전 제곱수일 때만 발생합니다. 예를 들어, 16의 약수는 1, 2, 4, 8, 16으로 5개인데, 이는 16이 완전 제곱수이기 때문입니다.

     따라서, 주어진 범위 내에서 완전 제곱수를 구하는 것이 핵심입니다.

     최적화된 코드

     이를 바탕으로, n이 주어졌을 때 n 이하의 완전 제곱수의 개수를 구하는 코드입니다:
     */
    
    if let input = readLine(), let n = Int(input), n > 0 {
        print(Double(n).squareRoot())
        let count = Int(Double(n).squareRoot())
        print(count)
    } else {
        print(0)
    }
}

/**
 이진 탐색 알고리즘으로 제곱근 계산하기
 •    이진 탐색: 이 코드는 제곱근을 찾기 위해 이진 탐색을 사용합니다. low는 가능한 제곱근의 최소값, high는 가능한 최대값을 나타냅니다.
 •    mid 계산: mid는 low와 high의 중간값으로, 이 값을 제곱하여 n과 비교합니다.
 •    제곱근 조건: mid * mid가 n과 같으면 정확한 제곱근을 찾은 것이므로 result에 값을 저장하고 종료합니다.
 •    범위 조정: mid * mid가 n보다 작으면 low를 mid + 1로, 크면 high를 mid - 1로 조정하여 탐색 범위를 줄입니다.
 •    결과: 이진 탐색이 끝나면 result에 n 이하의 가장 큰 정수 제곱근이 저장됩니다.

이 코드에서는 제곱근의 정수 부분만 구할 수 있지만, 이 문제에서는 충분합니다. Double(n).squareRoot() 메서드를 사용할 수 없는 상황에서 제곱근을 구하는 안전하고 효율적인 방법입니다.
 */

func squareRootWith() {
    
    if let input = readLine(), let n = Int(input), n > 0 {
        var low = 1
        var high = n
        var result = 1
        
        while low <= high {
            let mid = (low + high) / 2
            let midSquared = mid * mid
            
            if midSquared == n {
                result = mid
                break
            } else if midSquared < n {
                low = mid + 1
                result = mid
            } else {
                high = mid - 1
            }
        }
        
        print(result)
    } else {
        print(0)
    }
}

/** ⭐️
 이진 탐색(Binary Search)은 **정렬된 배열**이나 리스트에서 효율적으로 값을 찾는 알고리즘입니다. 이 알고리즘은 배열을 반복적으로 절반으로 나누면서, 목표 값을 찾을 때까지 탐색 범위를 좁혀갑니다. 이 과정에서 비교 횟수를 줄이기 때문에 매우 효율적입니다.

 ### 이진 탐색의 원리

 이진 탐색은 다음과 같은 방식으로 동작합니다:

 1. **중간 값 선택**: 배열이나 리스트의 중간 인덱스를 계산하여, 해당 인덱스의 요소를 선택합니다.
 2. **비교**: 선택한 중간 값과 목표 값을 비교합니다.
    - 만약 중간 값이 목표 값과 같다면, 탐색을 종료하고 해당 인덱스를 반환합니다.
    - 만약 중간 값이 목표 값보다 작다면, 목표 값은 오른쪽 절반에 있을 수 있으므로 왼쪽 절반을 버리고 오른쪽 절반을 탐색합니다.
    - 반대로, 중간 값이 목표 값보다 크다면, 목표 값은 왼쪽 절반에 있을 수 있으므로 오른쪽 절반을 버리고 왼쪽 절반을 탐색합니다.
 3. **반복**: 이 과정을 목표 값을 찾을 때까지 반복합니다. 만약 탐색 범위가 더 이상 존재하지 않으면, 목표 값이 배열에 없다는 것을 의미합니다.

 ### 이진 탐색의 시간 복잡도

 이진 탐색은 배열을 절반으로 나누는 과정을 반복하기 때문에, 탐색 과정에서 배열의 길이가 \( n \)이라면 최대 \( \log_2(n) \)번의 비교가 필요합니다. 따라서 이진 탐색의 시간 복잡도는 **O(log n)**입니다. 이는 선형 탐색(모든 요소를 하나씩 확인하는 방법)의 **O(n)** 시간 복잡도에 비해 훨씬 빠릅니다.

 ### 이진 탐색의 예시

 예를 들어, 다음과 같은 정렬된 배열이 있다고 가정해 봅시다:

 \[ [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] \]

 목표 값이 `13`인 경우, 이진 탐색은 다음과 같이 진행됩니다:

 1. 배열의 중간 값인 `9`와 `13`을 비교합니다. `9 < 13`이므로, `13`은 오른쪽 절반에 있을 수 있습니다.
 2. 오른쪽 절반 `[11, 13, 15, 17, 19]`을 선택하고, 다시 중간 값인 `15`와 비교합니다. `15 > 13`이므로, `13`은 왼쪽 절반에 있을 수 있습니다.
 3. 왼쪽 절반 `[11, 13]`을 선택하고, 다시 중간 값인 `13`과 비교합니다. 이 값은 목표 값과 일치하므로 탐색을 종료합니다.

 이진 탐색은 특히 데이터가 정렬되어 있는 경우 매우 효율적이며, 대규모 데이터 집합에서 목표 값을 빠르게 찾을 수 있습니다.
 */
